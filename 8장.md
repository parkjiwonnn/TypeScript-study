# 8장 JSX에서 TSX로

## 8.1 리액트 컴포넌트의 타입

- @types/react 패키지에 정의된 리액트 내장 타입

### (1) 클래스 컴포넌트 타입

```jsx
// React.Component, React.PureComponenet 타입 정의
// P와 S는 각각 props와 state를 의미함
interface Component<P = {}, S = {}, SS = any>
  extends ComponentLifecycle<P, S, SS> {}

class Component<P, S> {
  /* ...생략 */
}

class PureComponent<P = {}, S = {}, SS = any> extends Component<P, S, SS> {}
```

- **React.Component**
  - 리액트에서 기본적으로 사용하는 클래스 컴포넌트
  - render 메서드를 통해 UI 반환가능
  - setState 또는 props의 변화가 발생할 때마다 `render` 메서드가 호출되어 리렌더링
  - `shouldComponentUpdate` 메서드가 기본적으로 정의되어 있지 않음, 리렌더링 여부를 수동으로 제어하려면 직접 구현해야함
  - `shouldComponentUpdate` 메서드: 리액트 클래스 컴포넌트에서 컴포넌트의 리렌더링 여부를 제어할 수 있는 생명주기 메서드
  ```jsx
  import React, { Component } from "react";

  // Props의 타입 정의
  interface MyComponentProps {
    message: string;
    value: string;
  }

  // State의 타입 정의
  interface MyComponentState {
    count: number;
  }

  // Component의 제네릭 타입으로 Props와 State를 지정
  class MyComponent extends Component<MyComponentProps, MyComponentState> {
    shouldComponentUpdate(
      nextProps: MyComponentProps,
      nextState: MyComponentState
    ): boolean {
      // props나 state의 특정 값이 변경되지 않았다면, 리렌더링 방지
      if (
        nextProps.value === this.props.value &&
        nextState.count === this.state.count
      ) {
        return false;
        // 컴포넌트 다시 렌더링 하지 않는 경우
        // render 메서드와 그 이후 생명주기 메서드 호출되지 않음
      }
      return true;
    }

    render() {
      return <div>{this.props.message}</div>;
    }
  }

  export default MyComponent;
  ```
- **React.PureComponent**
  - React.Component를 상속받아서 생성됨
  - 주된 차이점은 `shouldComponentUpdate` 메서드를 자동으로 구현해줌
  - props와 state를 새로운 props와 state와 비교하여 변경된 부분이 있을 때만 리렌더링이 발생함
  - 불필요한 리렌더링을 방지하고 성능 최적화
  - state나 props에 복잡한 객체나 배열이 포함된 경우 올바르게 동작하지 않을 수 있으므로 상태의 구조를 단순하게 유지해야 함
  ```jsx
  import React, { PureComponent } from "react";

  // Props의 타입 정의
  interface MyPureComponentProps {
    message: string;
  }

  // PureComponent의 제네릭 타입으로 Props를 지정
  class MyPureComponent extends PureComponent<MyPureComponentProps> {
    render() {
      return <div>{this.props.message}</div>;
    }
  }

  export default MyPureComponent;
  ```

⇒ React.Component는 모든 리렌더링을 수동으로 제어할 수 있는 유연성을 제공, React.PureComponent는 자동으로 불필요한 리렌더링을 방지해 성능 최적화 가능

### (2) 함수 컴포넌트 타입

```jsx
// 함수 선언을 사용한 방식
function Welcome(props: WelcomeProps): JSX.Element {}

// 함수 표현식을 사용한 방식 - React.FC 사용
const Welcome: React.FC<WelcomeProps> = ({ name }) => {};

// 함수 표현식을 사용한 방식 - React.VFC 사용
const Welcome: React.VFC<WelcomeProps> = ({ name }) => {};

// 함수 표현식을 사용한 방식 - JSX.Element를 반환 타입으로 지정
const Welcome: ({ name }: WelcomeProps): JSX.Element => {};
```

- 함수 표현식을 사용하여 함수 컴포넌트를 선언할 때 가장 많이 볼 수 있는 형태는 React.FC 혹은 React.VFC로 타입을 지정하는 것
- FC는 FunctionComponent의 약자로 React.FC와 React.VFC는 리액트에서 함수 컴포넌트의 타입 지정을 위해 제공되는 타입

```jsx
type FC<P = {}> = FunctionComponent<P>;

interface FunctionComponent<P = {}> {
  // props에 children을 추가
  (props: PropsWithChildren<P>, context?: any): ReactElement<any, any> | null;
  // 기타 타입 정의
}

type VFC<P = {}> = VoidFunctionComponent<P>;

interface VoidFunctionComponent<P = {}> {
  // children 없음
  (props: P, context?: any): ReactElement<any, any> | null;
  // 기타 타입 정의
}
```

- React.FC는 암묵적으로 children을 포함하고 있기 때문에 해당 컴포넌트에서 children을 사용하지 않더라도 children props를 허용함
- children props가 필요하지 않은 컴포넌트에서는 더 정확한 타입 지정을 하기 위해 React.FC 보다 React.VFC를 많이 사용함
- 리액트 v18로 넘어오면서 React.VFC가 삭제되어 React.FC 또는 props 타입, 반환 타입을 직접 지정하는 형태로 타이핑해줘야 함

### (3) Children props 타입 지정

```jsx
type PropsWithChildren<P> = P & { children?: ReactNode | undefined };
```

- 가장 보편적인 children 타입은 ReactNode | undefined가 됨
- ReactNode는 ReactElement 외에도 boolean, number 등 여러 타입을 포함하고 있는 타입으로 구체적으로 타이핑하는 용도에는 적합하지 않음
- children에 대한 타입 지정은 다른 prop 타입 지정과 동일한 방식으로 지정 가능

```jsx
type WelcomeProps = {
  children: "천생연분" | "더 귀한 분" | "귀한 분" | "고마운 분",
};

type WelcomeProps = {
  children: string,
};

type WelcomeProps = {
  children: ReactElement,
};
```

### (4) render 메서드와 함수 컴포넌트의 반환 타입 - React.ReactElement vs JSX.Element vs React.ReactNode

- **ReactElement**: 리액트 컴포넌트를 객체 형태로 저장하기 위한 포맷
- **JSX.Element**: 리액트의 ReactElement를 확장하고 있는 타입이며, 글로벌 네임스페이스에 정의되어 있어서 외부 라이브러리에서 컴포넌트 타입을 재정의 할 수 있는 유연성을 제공함
- **ReactNode**: ReactElement 외에도 boolean, string, number 등의 여러 타입을 포함하고 있음
- 포함관계: ReactNode > ReactElement > JSX.Element

### (5) ReactElement, ReactNode, JSXElement 활용하기

- **ReactElement**
  - JSX의 createElement 메서드 호출로 생성된 리액트 엘리먼트를 나타내는 타입
  ```jsx
  const element = React.createElement(
    "hi",
    { className: "greeting" },
    "Hello, world!"
  );

  const element = {
    type: "hi",
    props: {
      className: "greeting",
      children: "Hello, world!",
    },
  };
  ```
- **ReactNode**
  - ReactChild 타입은 ReactElement | string | number로 정의되어 ReactElement 보다는 좀 더 넓은 범위를 갖고 있음
  ```jsx
  type ReactText = string | number;
  type ReactChild = ReactElement | ReactText;
  ```
  - ReactNode는 ReactChild 외에도 boolean, null, undefined 등 훨씬 넓은 범주의 타입을 포함함
  - 리액트의 render 함수가 반환할 수 잇는 모든 형태를 담고 있다고 볼 수 있음
  ```jsx
  type ReactFragment = {} | Iterable<ReactNode>; // ReactNode의 배열 형태
  type ReactNode =
    | ReactChild
    | ReactFragment
    | ReactPortal
    | boolean
    | null
    | undefined;
  ```
- **JSX.Element**
  - JSX.Element는 ReactElement의 특정 타입으로 props와 타입 필드를 any로 가지는 타입이라는 것을 알 수 있음
  ```jsx
  declare global {
  	namespace JSX {
  		interface Element extends React.ReactElement<any, any>{
  			//...
  		}
  		//...
  	}
  }
  ```
