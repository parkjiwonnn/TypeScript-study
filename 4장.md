# 4장

## 4.1 타입 확장하기

타입 확장: 기존 타입을 사용해서 새로운 타입을 정의하는 것  
interface와 type 키워드를 사용해서 타입을 정의하고, extends, 교차 타입, 유니온 타입을 사용하여 타입을 확장함

### (1) 타입 확장의 장점

1. 코드 중복을 줄일 수 있음  
   기존에 작성한 타입을 바탕으로 타입 확장을 함으로써 불필요한 코드 중복을 줄일 수 있음  
   BaseCartItem이 BaseMenuItem에서 확장되었다는 것을 쉽게 확인할 수 있는 것처럼 더 명시적인 코드 작성 가능

```
interface BaseMenuItem {
  itemName: string | null;
  itemImageUrl: string | null;
  stock: number | null;
}

interface BaseCartItem extends BaseMenuItem {
  quantity: number;
}
```

2. 확장성  
   타입 확장을 활용하면 관련 요구 사항이 생길 때마다 필요한 타입을 손쉽게 만들 수 있음  
   기존 요소에 대한 요구 사항이 변경되어도 기존 타입만 수정하고 확장된 타입은 수정하지 않아도 되기 때문에 효율적임

### (2) 유니온 타입

2개 이상의 타입을 조합하여 사용하는 방법으로 합집합으로 해석할 수 있음

```
type MyUnion = A | B
```

A 타입과 B 타입의 모든 값이 MyUnion 타입의 값이 됨  
유니온 타입으로 선언된 값은 유니온 타입에 포함된 모든 타입이 공통으로 갖고 있는 속성에만 접근 가능

```
interface CookingStep {
  orderId: string;
  price: number;
}

interface DeliveryStep {
  orderId: string;
  time: number;
}

function getDeliveryDistance(step: CookingStep | DeliveryStep) {
  return step.distance; // x
}
```

### (3) 교차 타입

기존 타입을 합쳐 필요한 모든 기능을 가진 하나의 타입으로 만드는 것

```
type MyIntersection = A & B;
```

교집합의 개념과 비슷하며 MyIntersection의 모든 원소는 집합 A의 원소이자 집합 B의 원소

### (4) extends와 교차 타입

extends 키워드를 사용해서 교차 타입을 작성할 수도 있음  
유니온 타입과 교차 타입을 사용한 새로운 타입은 오직 type 키워드로만 선언할 수 있음  
extends 키워드를 사용한 타입이 교차 타입과 100% 상응하지는 않음  
type 키워드는 교차 타입으로 선언되었을 때 새롭게 추가되는 속성에 대해 미리 알 수 없기 때문에 선언 시 에러가 발생하지 않음  
하지만 같은 속성에 대해 서로 호환되지 않는 타입이 선언되면 never 타입이 됨

## 4.2 타입 좁히기 - 타입 가드

타입 좁히기: 변수 또는 표현식의 타입 범위를 더 작은 범위로 좁혀나가는 과정  
더 정확하고 명시적인 타입 추론을 할 수 있고, 복잡한 타입을 작은 범위로 축소하여 타입 안정성을 높일 수 있음

### (1) 타입 가드에 따라 분기 처리하기
