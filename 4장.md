# 4장

## 4.1 타입 확장하기

타입 확장: 기존 타입을 사용해서 새로운 타입을 정의하는 것  
interface와 type 키워드를 사용해서 타입을 정의하고, extends, 교차 타입, 유니온 타입을 사용하여 타입을 확장함

### (1) 타입 확장의 장점

1. 코드 중복을 줄일 수 있음  
   기존에 작성한 타입을 바탕으로 타입 확장을 함으로써 불필요한 코드 중복을 줄일 수 있음  
   BaseCartItem이 BaseMenuItem에서 확장되었다는 것을 쉽게 확인할 수 있는 것처럼 더 명시적인 코드 작성 가능

```
interface BaseMenuItem {
  itemName: string | null;
  itemImageUrl: string | null;
  stock: number | null;
}

interface BaseCartItem extends BaseMenuItem {
  quantity: number;
}
```

2. 확장성  
   타입 확장을 활용하면 관련 요구 사항이 생길 때마다 필요한 타입을 손쉽게 만들 수 있음  
   기존 요소에 대한 요구 사항이 변경되어도 기존 타입만 수정하고 확장된 타입은 수정하지 않아도 되기 때문에 효율적임

### (2) 유니온 타입

2개 이상의 타입을 조합하여 사용하는 방법으로 합집합으로 해석할 수 있음

```
type MyUnion = A | B
```

A 타입과 B 타입의 모든 값이 MyUnion 타입의 값이 됨  
유니온 타입으로 선언된 값은 유니온 타입에 포함된 모든 타입이 공통으로 갖고 있는 속성에만 접근 가능

```
interface CookingStep {
  orderId: string;
  price: number;
}

interface DeliveryStep {
  orderId: string;
  time: number;
}

function getDeliveryDistance(step: CookingStep | DeliveryStep) {
  return step.distance; // x
}
```

### (3) 교차 타입

기존 타입을 합쳐 필요한 모든 기능을 가진 하나의 타입으로 만드는 것

```
type MyIntersection = A & B;
```

교집합의 개념과 비슷하며 MyIntersection의 모든 원소는 집합 A의 원소이자 집합 B의 원소

### (4) extends와 교차 타입

extends 키워드를 사용해서 교차 타입을 작성할 수도 있음  
유니온 타입과 교차 타입을 사용한 새로운 타입은 오직 type 키워드로만 선언할 수 있음  
extends 키워드를 사용한 타입이 교차 타입과 100% 상응하지는 않음  
type 키워드는 교차 타입으로 선언되었을 때 새롭게 추가되는 속성에 대해 미리 알 수 없기 때문에 선언 시 에러가 발생하지 않음  
하지만 같은 속성에 대해 서로 호환되지 않는 타입이 선언되면 never 타입이 됨

## 4.2 타입 좁히기 - 타입 가드

타입 좁히기: 변수 또는 표현식의 타입 범위를 더 작은 범위로 좁혀나가는 과정  
더 정확하고 명시적인 타입 추론을 할 수 있고, 복잡한 타입을 작은 범위로 축소하여 타입 안정성을 높일 수 있음

### (1) 타입 가드에 따라 분기 처리하기

타입스크립트에서의 분기 처리는 조건문과 타입 가드를 활용하여 변수나 표현식의 타입 범위를 좁혀 다양한 상황에 따라 다른 동작을 수행하는 것을 말함

타입 가드: 런타임에 조건문을 사용하여 타입을 검사하고 타입 범위를 좁혀주는 기능을 말함

1. 자바스크립트 연산자를 활용한 타입 가드
   typeof, instanceof, in과 같은 연산자를 사용해서 제어문으로 특정 타입 값을 가질 수밖에 없는 상황을 유도하여 자연스럽게 타입을 좁히는 방식  
   런타임에 유효한 타입 가드를 만들기 위해서 자바스크립트 연산자를 사용함
2. 사용자 정의 타입 가드
   사용자가 직접 어떤 타입으로 값을 좁힐지를 직접 지정하는 방식

### (2) 원시 타입을 추론할 때: typeof 연산자 활용하기

typeof 연산자를 활용하면 원시 타입에 대해 추론 가능  
typeof 연산자를 사용하여 검사할 수 있는 타입: `string`, `number`, `boolean`, `undefined`, `object`, `function`, `bigint`, `symbol`

typeof는 자바스크립트 타입 시스템만 대응할 수 있음  
자바스크립트의 동작 방식으로 인해 null과 배열 타입 등이 object 타입으로 판별되는 등 복잡한 타입을 검증하기에는 한계가 있음  
=> typeof 연산자는 원시 타입을 좁히는 용도로만 사용할 것을 권장

### (3) 인스턴스화된 객체 타입을 판별할 때: instanceof 연산자 활용하기

typeof 연산자를 주로 원시 타입을 판별하는 데 사용한다면, instanceof 연산자는 인스턴스화된 객체 타입을 판별하는 타입 가드로 사용할 수 있음

`A instanceof B` 형태로 사용하며 A에는 타입을 검사할 대상 변수, B에는 특정 객체의 생성자가 들어감  
instanceof는 A의 프로토타입 체인에 생성자 B가 존재하는지를 검사해서 존재한다면 true, 그렇지 않다면 false를 반환함

### (4) 객체의 속성이 있는지 없는지에 따른 구분: in 연산자 활용하기

in 연산자는 객체에 속성이 있는지 확인한 다음에 true 또는 false를 반환함  
in 연산자를 사용하면 속성이 있는지 없는지에 따라 객체 타입을 구분할 수 있음

`A in B` 형태로 사용하며 A라는 속성이 B 객체에 존재하는지를 검사함  
프로토타입 체인으로 접근할 수 있는 속성이면 전부 true를 반환

### (4) is 연산자로 사용자 정의 타입 가드 만들어 활용하기
