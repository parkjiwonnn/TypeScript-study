# 4장

## 4.1 타입 확장하기

- 타입 확장 : 기존 타입을 사용해서 새로운 타입을 정의하는 것
  - extends, 교차타입, 유니온 타입 사용
- 타입 정의 : interface, type 키워드 사용

### (1) 타입 확장의 장점

1. **코드 중복을 줄일 수 있음**
   - 기존에 작성한 타입을 바탕으로 타입 확장을 함으로써 불필요한 코드 중복을 줄일 수 있음
     ```jsx
     interface BaseMenuItem {
       itemName: string | null;
       itemImageUrl: string | null;
       stock: number | null;
     }

     interface BaseCartItem extends BaseMenuItem {
       quantity: number;
     }

     ---------------------------------

     type BaseMenuItem = {
     	itemName: string | null;
     	itemImageUrl: string | null;
     	itemDiscountAmount: number;
     	stock: number | null;
     };

     type BaseCartItem = {
     	quantity: number;
     } & BaseMenuItem;
     ```
2. **확장성**
   - 타입 확장을 활용하면 관련 요구 사항이 생길 때마다 필요한 타입을 손쉽게 만들 수 있음
   - 기존 요소에 대한 요구 사항이 변경되어도 기존 타입만 수정하고 확장된 타입은 수정하지 않아도 되기 때문에 효율적임

### (2) 유니온 타입

- 2개 이상의 타입을 조합하여 사용하는 방법

```jsx
type MyUnion = A | B;
```

- 유니온 타입으로 선언된 값은 유니온 타입에 포함된 모든 타입이 공통으로 갖고 있는 속성에만 접근 가능

```jsx
interface CookingStep {
  orderId: string;
  price: number;
}

interface DeliveryStep {
  orderId: string;
  time: number;
  distance: string;
}

function getDeliveryDistance(step: CookingStep | DeliveryStep) {
  return step.distance; // error
}
```

### (3) 교차 타입

- 기존 타입을 합쳐 필요한 모든 기능을 가진 하나의 타입으로 만드는 것

```jsx
type MyIntersection = A & B;
```

- 교차 타입에 포함된 타입이 갖고 있는 모든 속성에 접근 가능

```jsx
type BaedalProgress = CookingStep & DeliveryStep;

function logBaedalInfo(progress: BaedalProgress) {
  console.log(`주문 금액: ${progress.price}`);
  console.log(`배달 거리: ${progress.distance}`);
}
```

```jsx
type IdType = string | number;
type Numeric = number | boolean;

type Universal = IdType & Numeric; // number 타입
```

### (4) extends와 교차 타입

- extends 키워드를 사용해서 교차 타입을 작성할 수도 있음
- 유니온 타입과 교차 타입을 사용한 새로운 타입은 오직 type 키워드로만 선언할 수 있음

```jsx
interface BaseMenuItem {
  itemName: string | null;
  itemImageUrl: string | null;
  stock: number | null;
}

interface BaseCartItem extends BaseMenuItem {
  quantity: number;
}

--------------------------------

type BaseMenuItem = {
	itemName: string | null;
	itemImageUrl: string | null;
	itemDiscountAmount: number;
	stock: number | null;
};

type BaseCartItem = {
	quantity: number;
} & BaseMenuItem;
```

- extends 키워드를 사용한 타입이 교차 타입과 100% 상응하지는 않음
- type 키워드는 교차 타입으로 선언되었을 때 새롭게 추가되는 속성에 대해 미리 알 수 없기 때문에 선언 시 에러가 발생하지 않음

```jsx
interface DeliveryTip {
	tip: number;
}

interface Filter extends DeliveryTip {
	tip: string;
	// Interface 'Filter' incorrectly extends interface 'DeliveryTip'
	// Types of property 'tip' are incompatible
	// Type 'string' is not assignable to type 'number'
}

------------------------------

type DeliveryTip = {
	tip: number;
}

type Filter = DeliveryTip & {
	tip: string;
}; // tip이라는 같은 속성에 대해 서로 호환되지 않는 타입이 선언되어 never 타입
```

## 4.2 타입 좁히기 - 타입 가드

타입 좁히기: 변수 또는 표현식의 타입 범위를 더 작은 범위로 좁혀나가는 과정  
더 정확하고 명시적인 타입 추론을 할 수 있고, 복잡한 타입을 작은 범위로 축소하여 타입 안정성을 높일 수 있음

### (1) 타입 가드에 따라 분기 처리하기

타입스크립트에서의 분기 처리는 조건문과 타입 가드를 활용하여 변수나 표현식의 타입 범위를 좁혀 다양한 상황에 따라 다른 동작을 수행하는 것을 말함

타입 가드: 런타임에 조건문을 사용하여 타입을 검사하고 타입 범위를 좁혀주는 기능을 말함

1. 자바스크립트 연산자를 활용한 타입 가드
   typeof, instanceof, in과 같은 연산자를 사용해서 제어문으로 특정 타입 값을 가질 수밖에 없는 상황을 유도하여 자연스럽게 타입을 좁히는 방식  
   런타임에 유효한 타입 가드를 만들기 위해서 자바스크립트 연산자를 사용함
2. 사용자 정의 타입 가드
   사용자가 직접 어떤 타입으로 값을 좁힐지를 직접 지정하는 방식

### (2) 원시 타입을 추론할 때: typeof 연산자 활용하기

typeof 연산자를 활용하면 원시 타입에 대해 추론 가능  
typeof 연산자를 사용하여 검사할 수 있는 타입: `string`, `number`, `boolean`, `undefined`, `object`, `function`, `bigint`, `symbol`

typeof는 자바스크립트 타입 시스템만 대응할 수 있음  
자바스크립트의 동작 방식으로 인해 null과 배열 타입 등이 object 타입으로 판별되는 등 복잡한 타입을 검증하기에는 한계가 있음  
=> typeof 연산자는 원시 타입을 좁히는 용도로만 사용할 것을 권장

### (3) 인스턴스화된 객체 타입을 판별할 때: instanceof 연산자 활용하기

typeof 연산자를 주로 원시 타입을 판별하는 데 사용한다면, instanceof 연산자는 인스턴스화된 객체 타입을 판별하는 타입 가드로 사용할 수 있음

`A instanceof B` 형태로 사용하며 A에는 타입을 검사할 대상 변수, B에는 특정 객체의 생성자가 들어감  
instanceof는 A의 프로토타입 체인에 생성자 B가 존재하는지를 검사해서 존재한다면 true, 그렇지 않다면 false를 반환함

### (4) 객체의 속성이 있는지 없는지에 따른 구분: in 연산자 활용하기

in 연산자는 객체에 속성이 있는지 확인한 다음에 true 또는 false를 반환함  
in 연산자를 사용하면 속성이 있는지 없는지에 따라 객체 타입을 구분할 수 있음

`A in B` 형태로 사용하며 A라는 속성이 B 객체에 존재하는지를 검사함  
프로토타입 체인으로 접근할 수 있는 속성이면 전부 true를 반환

### (5) is 연산자로 사용자 정의 타입 가드 만들어 활용하기

직접 타입 가드 함수를 만들 수도 있는데, 이러한 방식의 타입 가드는 반환 타입이 타입 명제인 함수를 정의하여 사용할 수 있음  
타입 명제는 `A is B` 형식으로 작성하며 A는 매개변수 이름, B는 타입  
참/거짓의 진릿값을 반환하면서 반환 타입을 타입 명제로 지정하게 되면 반환 값이 참일 때 A 매개변수의 타입을 B 타입으로 취급하게 됨  
타입 명제: 함수의 반환 타입에 대한 타입 가드를 수행하기 위해 사용되는 특별한 형태의 함수

## 4.3 타입 좁히기 - 식별할 수 있는 유니온

태그된 유니온으로도 불리는 식별할 수 있는 유니온은 타입 좁히기에 널리 사용되는 방식

### (1) 에러 정의하기

유효성 에러가 발생하면 사용자에게 다양한 방식으로 에러를 보여줌  
크게 텍스트 에러, 토스트 에러, 얼럿 에러로 분류 가능  
모두 유효성 에러로 에러 코드와 에러 메세지를 가지고 있으며, 에러 노출 방식에 따라 추가로 필요한 정보가 있을 수 있음  
(ex) 토스트 에러는 토스트를 얼마 동안 띄울 것인지에 대한 정보가 필요함

### (2) 식별할 수 있는 유니온

에러 타입을 구분할 방법이 필요함  
각 타입이 비슷한 구조를 가지지만 서로 호환되지 않도록 만들어주기 위해서는 타입들이 서로 포함 관계를 가지지 않도록 정의해야 함  
식별할 수 있는 유니온: 타입 간의 구조 호환을 막기 위해 타입마다 구분할 수 있는 판별자를 달아주어 포함 관계를 제거하는 것

### (3) 식별할 수 있는 유니온의 판별자 선정

식별할 수 있는 유니온을 사용할 때 주의할 점: 식별할 수 있는 유니온의 판별자는 유닛 타입으로 선언되어야 정상적으로 동작함  
유닛 타입: 다른 타입으로 쪼개지지 않고 오직 하나의 정확한 값을 가지는 타입  
null, undefined, 리터럴 타입을 비롯해 true, 1 등 정확한 값을 나타내는 타입이 유닛 타입에 해당됨, 다양한 타입을 할당할 수 있는 void, string, number와 같은 타입은 유닛 타입으로 적용되지 않음
