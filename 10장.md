# 10장 상태 관리

## 10.1 상태 관리

### (1) 상태(State)

- 상태 : 리액트 애플리케이션에서의 상태는 랜더링에 영향을 줄 수 있는 동적인 데이터 값
- 시간이 지나면서 변할 수 있는 동적인 데이터, 값이 변경될 때마다 컴포넌트의 렌더링 결과물에 영향을 줌
- 지역 상태, 전역 상태, 서버 상태로 분류 가능
- 리액트 내부 API만으로도 상태 관리가 가능하지만 성능 문제와 상태의 복잡성으로 인해 Redux, MobX, Recoil 같은 외부 상태 관리 라이브러리를 주로 활용함
- 지역 상태 : 컴포넌트 내부에서 사용되는 상태
  - 체크박스의 체크 여부, 폼의 입력값 등
  - useState 훅을 가장 많이 사용하며 때에 따라 useReducer와 같은 훅을 사용하기도 함
- 전역 상태 : 앱 전체에 공유하는 상태
  - 여러 개의 컴포넌트가 전역 상태를 사용할 수 있으며 상태가 변경되면 컴포넌트들도 업데이트 됨
  - Prop drilling 문제를 피하고자 지역 상태를 해당 컴포넌트들 사이의 전역 상태로 공유할 수 있음
- 서버 상태 : 외부 서버에 저장해야 하는 상태
  - 사용자 정보, 글 목록 등
  - UI 상태와 결합하여 관리하게 되며 로딩 여부나 에러 상태 등을 포함
  - 지역 상태 또는 전역 상태와 동일한 방법으로 관리되며 react-query, SWR과 같은 외부 라이브러리를 사용하기도 함

### (2) 상태를 잘 관리하기 위한 가이드

- 상태는 애플리케이션의 복잡성을 증가시키고 동작을 예측하기 어렵게 만듦
- 상태가 업데이트 될 때마다 리렌더링이 발생하기 때문에 유지보수 및 성능 관점에서 상태의 개수를 최소화하는 것이 바람직함
- 시간이 지나도 변하지 않는다면 상태가 아니다
  - 컴포넌트가 마운트될 때만 스토어 객체 인스턴스를 생성하고, 컴포넌트가 언마운트될 때까지 해당 참조가 변하지 않을 경우
  - 렌더링 될 때마다 새로운 객체 인스턴스가 생성되어 props나 컨텍스트로 전달했을 시 매번 다른 객체로 인식되어 불필요한 리렌더링이 자주 발생할 수 있음
  - 컴포넌트 라이프사이클 내에서 마운트될 때 인스턴스가 생성되고, 렌더링될 때마다 동일한 객체 참조가 유지되도록 구현해야 함
- 파생된 값은 상태가 아니다
  - props나 기존 상태에서 개선될 수 있는 값은 상태가 아님
  - SSOT(single source of truth)는 어떠한 데이터도 단 하나의 출처에서 생성하고 수정해야 한다는 원칙을 의미
  - 다른 값에서 파생된 값을 상태로 관리하게 되면 기존 출처와는 다른 새로운 출처에서 관리하게 되는 것이므로 해당 데이터의 정확성과 일관성을 보장하기 어려움
- useState vs useReducer
  - useReducer를 권장하는 경우 : 다수의 하위 필드를 포함하고 있는 복잡한 상태 로직을 다룰 때
  - 다음 상태가 이전 상태에 의존적일 때

### (3) 전역 상태 관리와 상태 관리 라이브러리

- 상태는 사용하는 곳과 최대한 가까워야 하며 사용 범위를 제한해야 함
- 전역 상태로 사용하는 방법
  - 컨텍스트 API + useState 또는 useReducer
  - 외부 상태 관리 라이브러리(Redux, MobX, Recoil 등)
- 컨텍스트 API(Context API)
  - 다른 컴포넌트들과 데이터를 쉽게 공유하기 위한 목적으로 제공되는 API
  - Prop Drilling 같은 문제를 해결하기 위한 도구로 활용됨
  - 전역적으로 공유해야 하는 데이터를 컨텍스트로 제공하고 해당 컨텍스트를 구독한 컴포넌트에서만 데이터를 읽을 수 있게 됨
  - UI 테마 정보나 로케일 데이터같이 전역적으로 제공하거나 컴포넌트의 props를 하위 컴포넌트에게 계속해서 전달해야 할 때 유용하게 사용할 수 있음

## 10.2 상태 관리 라이브러리

### (1) MobX

- 객체 지향 프로그래밍과 반응형 프로그래밍 패러다임의 영향을 받은 라이브러리
- 상태 변경 로직을 단순하게 작성할 수 있음
- 복잡한 업데이트 로직을 라이브러리에 위임할 수 있음
- 객체 지향 스타일로 코드를 작성하는 데 익숙하다면 MobX 추천
- 데이터가 언제, 어떻게 변하는지 추적하기 어렵기 때문에 트러블슈팅에 어려움을 겪을 수 있음

### (2) Redux

- 함수형 프로그래밍의 영향을 받은 라이브러리
- 특정 UI 프레임워크에 종속되지 않아 독립적으로 상태 관리 라이브러리를 사용할 수 있음
- 오랜 기간 사용되어 왔기 때문에 다양한 요구 사항에 대해 충분히 검증됨
- 상태 변경 추적에 최적화되어 있어, 특정 상황에서 발생한 애플리케이션 문제의 원인을 파악하는 데 용이
- 단순한 상태 설정에도 많은 보일러플레이트가 필요하고, 사용 난도가 높다는 단점이 있음

### (3) Recoil

- 상태를 저장할 수 있는 Atom과 해당 상태를 변형할 수 있는 순수 함수 selector를 통해 상태를 관리하는 라이브러리
- Redux에 비해 보일러플레이트가 적고 난이도가 쉬워 배우기 쉬움
- 라이브러리가 아직 실험적인 상태이기 때문에 다양한 요구 사항에 대한 충분한 검증이 이루어지지 않았음
- Recoil 상태를 공유하기 위해 컴포넌트들은 RecoilRoot 하위에 위치해야 함
- Atom은 상태의 일부를 나타내며 어떤 컴포넌트에서든 읽고 쓸 수 있도록 제공됨

### (4) Zustand

- Flux 패턴을 사용하며 많은 보일러플레이트를 가지지 않는 훅 기반의 편리한 API 모듈을 제공함
- 클로저를 활용하여 스토어 내부 상태를 관리함으로써 특정 라이브러리에 종속되지 않는 특징이 있음
- 상태와 상태를 변경하는 액션을 정의하고 반환된 훅을 어느 컴포넌트에서나 임포트하여 원하는 대로 사용할 수 있음
