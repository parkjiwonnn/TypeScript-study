# 9장 훅

## 9.1 리액트 훅

- 리액트에 훅이 추가되기 이전에는 클래스 컴포넌트에서만 상태를 가질 수 있었음
- 클래스 컴포넌트에서는 하나의 생명주기 함수에서만 상태 업데이트에 따른 로직을 실행시킬 수 있었음
- 모든 상태를 하나의 함수 내에서 처리하다 보니 관심사가 뒤섞이게 되었고 상태에 따른 테스트나 잘못 발생한 사이드 이펙트의 디버깅이 어려워짐

### (1) useState

- 기존 배열 요소에 없는 속성을 추가하려고 할 때, 예상치 못한 사이드 이펙트가 발생함
- 기능을 추가하거나 수정할 때 해당 컴포넌트에서 다루는 상태 타입을 모른다면 치명적인 에러가 발생할 수 있음
- 타입스크립트를 사용하면 에러를 사전에 방지할 수 있음

### (2) 의존성 배열을 사용하는 훅

- useEffect, useLayoutEffect
  - useEffect 훅은 deps가 변경되었는지를 얕은 비교로만 판단하기 때문에 실제 객체 값이 바뀌지 않았더라도 객체의 참조 값이 변경되면 콜백 함수가 실행됨
  - useEffect는 componentDidUpdate와 같은 기존 생명주기 함수와는 다르게, 레이아웃 배치와 화면 렌더링이 모두 완료된 후에 실행됨
  - useLayoutEffect를 사용하면 화면에 해당 컴포넌트가 그려지기 전에 콜백 함수를 실행함
- useMemo, useCallback
  - 둘 다 이전에 생성된 값 또는 함수를 기억하며, 동일한 값과 함수를 반복해서 생성하지 않도록 해주는 훅
  - 어떤 값을 계산하는 데 오랜 시간이 걸릴 때나 렌더링이 자주 발생하는 form에서 useMemo나 useCallback을 유용하게 사용할 수 있음
  - deps 배열을 갖고 있으며 해당 의존성이 변경되면 값을 다시 계산하게 됨
  - 얕은 비교를 수행하기 때문에 deps 배열이 변경되지 않았는데도 다시 계산되지 않도록 주의해야 함
  - 메모이제이션: 이전에 계산한 값을 저장함으로써 같은 입력에 대한 연산을 다시 수행하지 않도록 최적화하는 기술
  - 과도하게 메모이제이션하면 컴포넌트의 성능 향상이 보장되지 않을 수 있음
