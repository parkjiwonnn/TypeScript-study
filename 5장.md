# 5장 타입 활용하기

## 5.1 조건부 타입

- 조건부 타입을 사용해 조건에 따라 출력 타입을 다르게 도출할 수 있음
- 자바스크립트의 삼항 연산자와 동일한 형태를 가짐
- 중복되는 타입 코드를 제거하고 상황에 따라 적절한 타입을 얻을 수 있기 때문에 더욱 정확한 타입 추론을 할 수 있음

### (1) extends와 제네릭을 활용한 조건부 타입

- 조건부 타입에서 extends를 사용할 때는 자바스크립트 삼항 연산자와 함께 사용

```jsx
T extends U ? X : Y
// 타입 T를 U에 할당할 수 있으면 X 타입, 아니면 Y 타입으로 결정됨을 의미
```

### (2) 조건부 타입을 사용하지 않았을 때의 문제점

- 인자로 넣는 타입에 알맞은 타입을 반환하고 싶지만, 타입 설정이 유니온으로만 되어있으면 타입스크립트는 해당 타입에 맞는 타입을 추론할 수 없음
- 인자에 따라 반환되는 타입을 다르게 설정하고 싶다면 extends를 사용한 조건부 타입을 활용하면 됨

### (3) extends 조건부 타입을 활용하여 개선하기

- 제네릭과 extends를 함께 사용해 제네릭으로 받는 타입을 제한함, 따라서 개발자는 잘못된 값을 넘길 수 없기 때문에 휴먼 에러를 방지할 수 있음
- extends를 활용해 조건부 타입을 설정하여 반환 값을 사용자가 원하는 값으로 구체화할 수 있음, 이에 따라 불필요한 타입 가드, 타입 단언 등을 방지할 수 있음

### (4) infer를 활용하여 타입 추론하기

- 삼항 연산자를 사용한 조건문의 형태를 가지는데, extends로 조건을 서술하고 infer로 타입을 추론하는 방식을 취함

```jsx
type UnpackPromise<T> = T extends Promise<infer K>[] ? K : any;
// 제네릭으로 T를 받아 T가 Promise로 래핑된 경우라면 K를 반환하고, 그렇지 않은 경우에는 any를 반환함
// Promise<infer K>는 Promise의 반환 값을 추론해 해당 값의 타입을 K로 한다는 의미
```

## 5.2 템플릿 리터럴 타입 활용하기

- 템플릿 리터럴 타입 : 자바스크립트의 템플릿 리터럴 문법을 사용해 특정 문자열에 대한 타입을 선언할 수 있는 기능

```jsx
// 템플릿 리터럴 적용 x
type Direction =
	| "top"
	| "topLeft"
	| "topRight"
	| "botton"
	| "bottonLeft"
	| "bottonRight";

// 템플릿 리터럴 적용 o
type Vertical = "top" | "botton";
type Horizon = "left" | "right";

type Direction = Vertical | `${Vertical}${Capitalize<Horizon>}`;}
```

## 5.3 커스텀 유틸리티 타입 활용하기

- 타입스크립트에서 제공하는 유틸리티 타입만으로는 타입을 표현하는 데 한계를 느낄 때 유틸리티 타입을 활용한 커스텀 유틸리티 타입을 활용할 수 있음

### (1) 유틸리티 함수를 활용해 styled-components의 중복 타입 선언 피하기

- Props 타입과 styled-components 타입의 중복 선언 및 문제점

### (2) PickOne 유틸리티 함수

- 타입스크립트에는 서로 다른 2개 이상의 객체를 유니온 타입으로 받을 때 타입 검사가 제대로 진행되지 않는 이슈가 있음
  ```jsx
  type Card = {
  	card: string
  };

  type Account = {
  	account: string
  };

  function withdraw(type: Card | Account) {
  	...
  }

  withdraw({card: "hyundai", account: "hana"});
  // withdraw 함수의 인자로 card, account 중 하나만 받고 싶지만 두 속성을 모두 받아도 타입 에러가 발생하지 않음
  // 두 속성이 모두 포함되어도 합집합의 범주에 들어가기 때문
  ```

1. 식별할 수 있는 유니온으로 객체 타입을 유니온으로 받기

   - 식별할 수 있는 유니온 : 각 타입에 type이라는 공통된 속성을 추가하여 구분짓는 방법

   ```jsx
   type Card = {
   	type: "card";
   	card: string;
   }

   type Account = {
   	type: "account";
   	account: string
   };

   function withdraw(type: Card | Account) {
   	...
   }

   withdraw({type: "card", card: "hyundai"});
   withdraw({type: "account", account: "hana"});
   ```

   - 식별할 수 있는 유니온으로 문제를 해결할 수 있지만 일일이 type을 다 넣어줘야 하는 불편함이 생김
   - 실수로 수정하지 않은 부분이 생긴다면 또 다른 문제가 발생할 수 있음

2. PickOne 커스텀 유틸리티 타입 구현하기

   - 선택하고자 하는 하나의 속성을 제외한 나머지 값을 옵셔널 타입 + undefined로 설정하면 원하고자 하는 속성만 받도록 구현 가능

   ```jsx
   type PickOne<T> = {
   	[P in keyof T]: Record<P, T[P]> & Partial<Record<Exclude<keyof T, P>, undefined>>;
   }[keyof T];
   ```

3. PickOne 살펴보기

   ```jsx
   type One<T> = { [P in keyof T]: Record<P, T[P]> }[keyof T];
   ```

   - `[P in keyof T]`에서 T는 객체로 가정하기 때문에 P는 T 객체의 키값을 말함
   - `Record<P, T[P]>`는 P 타입을 키로 가지고, value는 P를 키로 둔 T 객체의 값의 레코드 타입을 말함
   - 따라서 `{ [P in keyof T]: Record<P, T[P]> }` 에서 키는 T 객체의 키 모음이고, value는 해당 키의 원본 객체 T를 말함
   - 위 타입에서 다시 `[keyof T]` 의 키값으로 접근하기 때문에 최종 결과는 전달받은 T와 같음

   ```jsx
   type ExcludeOne<T> = { [P in keyof T]: Partial<Record<Exclude<keyof T, P>, undefined>> }[keyof T];
   ```

   - `[P in keyof T]` 에서 T는 객체로 가정하기 때문에 P는 T 객체의 키 값을 말함
   - `Exclude<keyof T, P>` 는 T 객체가 가진 키값에서 P 타입과 일치하는 키 값을 제외함, 이 타입을 A라고 가정
   - `Record<A, undefined>` 는 키로 A 타입을, 값으로 undefined 타입을 갖는 레코드 타입, 전달 받은 객체 타입을 모두 { [key] : undefined } 형태로 만듦, 이 타입을 B라고 가정
   - `Partial<B>` 는 B 타입을 옵셔널로 만들기 때문에 { [key]? : undefined }와 같음
   - 최종적으로 [P in keyof T]로 매핑된 타입에서 동일한 객체의 키값인 [keyof T]로 접근하기 때문에 4번 타입이 반환됨
