# 7장 비동기 호출

## 7.1 API 요청

### (1) fetch로 API 요청하기

- API URL 수정사항이 발생했을 때 이미 컴포넌트 내부에 깊숙히 자리 잡은 비동기 호출 코드는 변경 요구에 취약함
- URL 변경 뿐만 아니라 ‘여러 서버에 API를 요청할 때 타임아웃 설정이 필요하다’ 또는 ‘모든 요청에 커스텀 헤더가 필요하다’ 같은 새로운 API 요청 정책이 추가될 때마다 계속해서 비동기 호출 코드를 수정해야 하는 번거로움이 발생함

```jsx
import React, { useEffect, useState } from "react";

const CartBadge: React.FC = () => {
  const [cartCount, setCartCount] = useState(0);

  useEffect(() => {
    fetch("https://api.baemin.com/cart")
      .then((response) => response.json())
      .then(({ cartItem }) => {
        setCartCount(cartItem.length);
      });
  }, []);

  return <>{/* cartCount 상태를 이용하여 컴포넌트 렌더링 */}</>;
};
```

### (2) 서비스 레이어로 분리하기

- 여러 API 요청 정책이 추가되어 코드가 변경될 수 있다는 것을 감안한다면, 비동기 호출 코드는 컴포넌트 영역에서 분리되어 다른 영역(서비스 레이어)에서 처리되어야 함
- fetch 함수를 호출하는 부분이 서비스 레이어로 이동하고, 컴포넌트는 서비스 레이어의 비동기 함수를 호출하여 그 결과를 받아와 렌더링하는 흐름이 됨
- 단순히 fetch 함수를 분리하는 것만으로는 API 요청 정책이 추가되는 것을 해결하기 어려움

### (3) Axios 활용하기

- fetch는 내장 라이브버리이기 때문에 따로 임포트하거나 설치할 필요 없이 사용할 수 있음
- 많은 기능을 사용하려면 직접 구현해서 사용해야하기 때문에 fetch 함수를 직접 쓰는 대신 Axios 라이브러리를 사용하면 편함
- API Entry가 2개 이상일 경우에는 각 서버의 기본 URL을 호출하도록 2개 이상의 API 요청을 처리하는 인스턴스를 따로 구성해야 함

```jsx
const apiRequester: AxiosInstance = axios.create(defaultConfig);
const orderApiRequester: AxiosInstance = axios.create({
  baseURL: "https://api.baemin.or/",
  ...defaultConfig,
});
const orderCartApiRequester: AxiosInstance = axios.create({
  baseURL: "https://cart.baemin.order/",
  ...defaultConfig,
});
```

### (4) Axios 인터셉터 사용하기

- 각각의 requester는 서로 다른 역할을 담당하는 다른 서버이기 때문에 requester별로 다른 헤더를 설정해줘야 하는 로직이 필요할 수 있음
- 인터셉터 기능을 사용하여 requester에 따라 비동기 호출 내용을 추가해서 처리할 수 있음
- API 에러를 처리할 때 하나의 에러 객체로 묶어서 처리할 수 있음

### (5) API 응답 타입 지정하기

- 같은 서버에서 오는 응답의 형태는 대체로 통일되어 있어서 앞서 소개한 API의 응답 값은 하나의 Response 타입으로 묶일 수 있음
- API 요청 및 응답 값 중에서는 하나의 API 서버에서 다른 API 서버로 넘겨주기만 하는 값도 존재할 수 있음, 해당 값이 어떤 응답이 들어있는지 알 수 없거나 값의 형식이 달라지더라도 로직에 영향을 주지 않는 경우에는 unknown 타입을 사용하여 알 수 없는 값임을 표현함

### (6) 뷰 모델(View Model) 사용하기

- API 응답은 변할 가능성이 크기 때문에 뷰 모델을 사용하여 API 변경에 따른 범위를 한정해줘야 함
- 뷰 모델을 만들면 API 응답이 바뀌어도 UI가 깨지지 않게 개발할 수 있음
- API 응답에는 없는 도메인 개념을 넣을 때 백엔드나 UI에서 로직을 추가하여 처리할 필요 없이 간편하게 새로운 필드를 뷰 모델에 추가할 수 있음

### (7) Superstruct를 사용해 런타임에서 응답 타임 검증하기

- Superstruct 라이브러리를 사용하면 인터페이스 정의와 자바스크립트 데이터의 유효성 검사를 쉽게 할 수 있음
- Superstruct는 런타임에서의 데이터 유효성 검사를 통해 개발자와 사용자에게 자세한 런타임 에러를 보여주기 위해 고안됨
- 컴파일 단계가 아닌 런타임에서도 적절한 데이터인지를 확인하는 검사가 필요할 때 유용하게 사용할 수 있음

## 7.2 API 상태 관리하기

### (1) 상태 관리 라이브러리에서 호출하기

- 상태 관리 라이브러리의 비동기 함수들은 서비스 코드를 사용해서 비동기 상태를 변화시킬 수 있는 함수를 제공함
- 컴포넌트는 이러한 함수를 사용하여 상태를 구독하며, 상태가 변경될 때 컴포넌트를 다시 렌더링하는 방식으로 동작
- Redux는 비동기 상태가 아닌 전역 상태를 위해 만들어진 라이브러리이기 때문에 미들웨어라고 불리는 여러 도구를 도입하여 비동기 상태를 관리함 → 보일러플레이트 코드 코드가 많아지는 등 간편하게 비동기 상태를 관리하기 어려운 상황도 발생
- MobX 같은 라이브러리에서는 이러한 불편함을 개선하기 위해 비동기 콜백 함수를 분리하여 액션으로 만들거나 runInAction과 같은 메서드를 사용하여 상태 변경을 처리함

### (2) 훅으로 호출하기

- react-query나 userSwr같은 훅을 사용한 방법은 상태 변경 라이브러리를 사용한 방식보다 훨씬 간단함
- 이러한 훅은 캐시를 사용하여 비동기 함수를 호출하며, 상태 관리 라이브러리에서 발생했던 의도치 않은 상태 변경을 방지하는 데 도움이 됨
- 상태 관리 라이브러리에서는 비동기로 상태를 변경하는 코드가 점점 추가되면 전역 상태 관리 스토어가 비대해짐
- 단순히 상태를 변경하는 액션이 증가하는 것 뿐만 아니라 전역 상태 자체도 복잡해짐
- 에러 발생, 로딩 중 등과 같은 상태는 전역으로 관리할 필요가 거의 없음
- 다른 컴포넌트가 에러 상태인지, 성공 상태인지를 구독하는 경우 컴포넌트의 결합도와 복잡도가 높아져 유지보수를 어렵게 만들 수 있음

## 7.3 API 에러 핸들링

### (1) 타입 가드 활용하기

- Axios 라이브러리에서는 Axios 에러에 대해 isAxiosError라는 타입 가드를 제공함
- 사용자 정의 타입 가드를 정의할 때는 타입 가드 함수의 반환 타입으로 parameterName is Type 형태의 타입 명제를 정의해주는 것이 좋음
- 이때 parameterName은 타입 가드 함수의 시그니처에 포함된 매개변수여야 함

### (2) 에러 서브클래싱하기

- 실제 요청을 처리할 때 단순한 서버 에러도 발생하지만 인증 정보 에러, 네트워크 에러, 타임 아웃 에러 같은 다양한 에러가 발생하기도 함 → 이를 명시적으로 표시하기 위해서 서브클래싱을 활용할 수 있음
- **서브클래싱**: 기존 클래스를 확장하여 새로운 클래스를 만드는 과정을 말함

### (3) 인터셉터를 활용한 에러 처리

- Axios 같은 페칭 라이브러리는 인터셉터 기능을 제공함 → HTTP 에러에 일관된 로직을 적용할 수 있음

### (4) 에러 바운더리를 활용한 에러 처리

- **에러 바운더리**: 리액트 컴포넌트 트리에서 에러가 발생할 때 공통으로 에러를 처리하는 리액트 컴포넌트
- 에러 바운더리를 사용하면 리액트 컴포넌트 트리 하위에 있는 컴포넌트에서 발생한 에러를 캐치하고, 해당 에러를 가장 가까운 부모 에러 바운더리에서 처리하게 할 수 있음
- 에러 바운더리는 에러가 발생한 컴포넌트 대신에 에러 처리를 하거나 예상치 못한 에러를 공통 처리할 때 사용할 수 있음

## 7.4 API 모킹

- 프론트엔드 개발이 서버 개발보다 먼저 이루어지거나 서버와 프론트엔드 개발이 동시에 이루어지는 경우가 더 많음
- 임시 변수를 만들어서 우선 UI를 구현할 수 있으나, POST 요청을 보내야 하거나 요청 응답에 따라 각기 다른 팝업을 보여주어야 할 경우 → 모킹 사용
- **모킹**: 가짜 모듈을 활용하는 것
- dev 서버가 불안정하거나 AWS 등에 문제가 생겼을 때와 같은 서버 상태에 문제가 발생한 경우에도 서버의 영향을 받지 않고 프론트엔드 개발을 할 수 있게 됨

### (1) JSON 파일 불러오기

- 간단한 조회만 필요한 경우에는 JSON 파일을 만들거나 자바스크립트 파일 안에 JSON 형식의 정보를 저장하고 export 해주는 방식을 사용
- 이후 GET 요청에 파일 경로를 삽입해주면 조회 응답으로 원하는 값을 받을 수 있음
- 별도의 환경 설정이 필요하지 않아 쉽게 구현 가능
- 추후에 요청 경로를 바꿔야 함

### (2) NextApiHandler 활용하기

- 프로젝트에서 Next.js를 사용하고 있다면 NextApiHandler를 활용할 수 있음
- 하나의 파일 안에 하나의 핸들러를 default export로 구현해야 하며 파일의 경로가 요청 경로가 됨
- 핸들러는 응답하고자 하는 값을 정의하고 핸들러 안에서 요청에 대한 응답을 정의함

### (3) API 요청 핸들러에 분기 추가하기

- 요청 경로를 수정하지 않고 평소에 개발할 때 필요한 경우에만 실제 요청을 보내고 그 외에는 목업을 사용하여 개발하고 싶을 때 API 요청을 훅 또는 별도 함수로 선언해준 다음 조건에 따라 목업 함수를 내보내거나 실제 요청 함수를 내보낼 수 있음
- 필요한 경우에만 실제 API에 요청을 보내고 평소에는 서버에 의존하지 않고 개발할 수 있게 됨
- 모든 API 요청 함수에 if 분기문을 추가해야 하므로 번거롭게 느껴질 수도 있음
