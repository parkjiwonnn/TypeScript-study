# 12장 타입스크립트 프로젝트관리

## 12.1 앰비언트 타입 활용하기

### (1) 앰비언트 타입 선언

- 앰비언트 타입 선언
  - .d.ts 확장자를 가진 파일에서는 타입 선언만 할 수 있으며 값을 표현할 수는 없음
  - 값을 포함하는 일반적인 선언과 구별하기 위해 .d.ts 확장자를 가진 파일에서 하는 타입 선언을 엠비언트 타입 선언이라고 부름
  - 앰비언트 타입 선언으로 값을 정의할 수는 없지만 declare라는 키워드를 사용하여 어딘가에 자바스크립트 값이 존재한다는 사실을 선언할 수 있음
  - declare: 타입스크립트 컴파일러에 어떤 것의 존재 여부를 명시해주는 역할, 단순히 존재 여부만 알려주기 때문에 컴파일 대상이 아님
- 대표적인 앰비언트 타입 선언 활용 사례
  - _.js 또는 _.ts 형식이 아닌 파일을 임포트할 때 종종 에러가 발생
  - 타입스크립트는 기본적으로 .ts와 .js 파일만 이해하며 그 외의 다른 파일 형식은 인지하지 못함
  - 알지 못하는 파일 형식을 모듈로 가져오려고 하면 에러 발생
  - declare 키워드를 사용하여 특정 형식을 모듈로 선언하면 타입스크립트 컴파일러에 미리 정보를 제공함으로써 에러를 수정할 수 있게 됨
  ```jsx
  declare module "*.png" {
  	const src: string;
  	export default src;
  }
  ```
- 자바스크립트로 작성된 라이브러리
  - 자바스크립트로 구현된 라이브러리는 타입 선언이 존재하지 않음
  - 타입스크립트에서 해당 라이브러리를 사용할 수는 있지만 타입 선언이 없으므로 임포트한 모듈은 모두 any로 추론됨
  - tsconfig.json 파일에서 any를 사용하지 못하게 설정했다면 프로젝트가 빌드되지 않음
  - 자바스크립트 라이브러리 내부 함수와 변수의 타입을 앰비언트 타입으로 선언하면 타입스크립트는 자동으로 .d.ts 확장자를 가진 파일을 검색하여 타입 검사를 진행하게 되므로 문제없이 컴파일됨
  - 앰비언트 타입 선언은 타입스크립트에게 자바스크립트 코드 안에 어떤 정보가 있는지 알려주는 도구
- 타입스크립트로 작성된 라이브러리
  - 타입스크립트로 작성된 라이브러리도 자바스크립트 파일과 .d.ts 파일로 배포되는 것이 일반적
  - 자바스크립트 파일과 .d.ts 파일로 배포하면 라이브러리 코드를 따로 컴파일하지 않아도 되기 때문에 컴파일 시간이 크게 줄어듦
  - .d.ts 파일이 있기 때문에 사용자는 .d.ts 파일에 정의된 타입 정보를 활용하여 라이브러리를 사용할 수 있음
  - tsconfig.json 파일의 declaration을 true로 설정하면 타입스크립트 컴파일러는 자동으로 .d.ts 파일을 생성함
- 자바스크립트 어딘가에 전역 변수가 정의되어 있음을 타입스크립트에 알릴 때
  - 타입스크립로 직접 구현하지 않았지만 실제 자바스크립트 어딘가에 전역 변수가 정의되어 있는 상황을 타입스크립트에 알릴 때 앰비언트 타입 선언을 사용
  - 네이티브 앱에서 Window 전역 개체에 deviceId나 appVersion 같은 값을 할당해주는 시나리오가 있다고 가정할 때, Window 객체의 속성은 타입스크립트로 직접 정의한 값이 아니기 때문에 타입스크립트는 해당 속성이 Window 객체의 타입이 존재하지 않는다고 판단
  - global namespace에 있는 Window 객체에 해당 속성이 정의되어 있다는 것을 나타내기 위해 앰비언트 타입 선언 활용 가능
  ```jsx
  declare global {
  	interface Window {
  		deviceId: string | undefined;
  		appVersion: string;
  	}
  }
  ```

### (2) 앰비언트 타입 선언 시 주의점

- 타입스크립트로 만드는 라이브러리에는 불필요
  - tsconfig.json의 declaration을 true로 설정하면 타입스크립트 컴파일러가 .d.ts 파일을 자동으로 생성해주기 때문에 수동으로 .d.ts 파일을 작성할 필요가 없음
- 전역으로 타입을 정의하여 사용할 때 주의해야 할 점
  - 서로 다른 라이브러리에서 동일한 이름의 앰비언트 타입 선언을 하면 충돌이 발생하여 어떤 타입 선언이 적용될지 알기 어렵고, 의도한 대로 동작하지 않을 수 있음

### (3) 앰비언트 타입 선언을 잘못 사용했을 때의 문제점

- .ts 파일 내부에 앰비언트 변수를 선언할 때 앰비언트 타입의 의존성 관계가 보이지 않기 때문에 변경에 의한 영향 범위를 파악하기 어려움
- declare 키워드를 사용한 앰비언트 타입 선언은 .d.ts 파일이 아닌 .ts, .tsx 파일 내에서도 가능
- 앰비언트 변수 선언은 어느 곳에나 영향을 줄 수 있기 때문에 일반 타입 선언과 섞이게 되면 앰비언트 선언이 어떤 파일에 포함되어 있는지 파악하기 어려워짐
- .d.ts 확장자 파일 내에서 앰비언트 타입 선언을 하는 것은 일종의 개발자 간의 약속

### (4) 앰비언트 타입 활용하기

- 타입을 정의하여 임포트 없이 전역으로 공유
  - .d.ts 파일에서의 앰비언트 타입 선언은 전역 변수와 같은 역할을 함
  - 앰비언트 타입을 선언하면 모든 코드 내에서 임포트하지 않고 사용가능
- declare type 활용하기
  - 보편적으로 많이 사용하는 커스텀 유틸리티 타입을 declare type으로 선언하여 전역에서 사용가능
- declare namespace 활용하기
  - node.js 환경에서 .env 파일을 사용할 때, declare namespace를 활용하여 process.env로 설정값을 손쉽게 불러오고 환경변수의 자동 완성 기능을 쓸 수 있음
  - process.env를 통해 접근하는 변수의 타입을 지정할 수 있기 때문에 as 단언을 사용하지 않아도 됨
- declare global 활용하기
  - declare global 키워드는 전역 변수를 선언할 때 사용함
  - 예시로 전역 변수인 Window 객체의 스코프에서 사용되는 모듈이나 변수 추가 가능

## 12.2 스크립트와 설정 파일 활용하기

### (1) 스크립트 활용하기

- 실시간으로 타입을 검사하자
  - 타입스크립트 프로젝트에서는 에디터가 가능한 빠르게 타입 에러를 감지해주지만 컴퓨터 성능이 떨어지거나 프로젝트 규모가 커지면 속도가 느려짐
  ```jsx
  yarn tsc -noEmit -incremental -w
  ```
  - 위 스크립트를 사용하면 실시간으로 에러 확인 가능
  - 프로젝트의 tsc(타입스크립트 컴파일러) 실행
- 타입 커버리지 확인하기
  - 현재 프로젝트에서 타입스크립트를 얼마나 적절하게 쓰고 있는지 확인하고 싶을 때 아래 스크립트 사용
  ```jsx
  npx type-coverage -detail
  ```

### (2) 설정 파일 활용하기

- 타입스크립트 컴파일 속도 높이기
  - tsconfig의 incremental 속성을 활용하여 타입스크립트의 컴파일 속도를 높일 수 있음
  - incremental 속성을 true로 설정하면 변경된 부분만 컴파일하게 됨
  - 모든 대상을 컴파일하지 않아도 되므로 컴파일타임을 줄일 수 있음
  ```jsx
  // tsconfig에 추가
  {
  	"compilerOptions": {
  		...
  		incremental: true
  	}
  }
  ```
  ```jsx
  // 스크립트 활용
  yarn tsc -noEmit -incremental -diagnostic
  ```

### (3) 에디터 활용하기

- 에디터에서 타입스크립트 서버 재시작하기
  - VSCode나 WebStorm과 같은 자바스크립트 IDE에서 프로그래밍하다 보면 정의된 타입이 있는 객체인데도 임포트되지 않거나 자동 완성 기능이 동작하지 않는 경우를 볼 수 있음
  - 타입스크립트 서버 재실행하면 해결 가능
  - VSCode에서는 Ctrl + Shift + P 누르고 실행

## 12.3 타입스크립트 마이그레이션

### (1) 타입스크립트 마이그레이션의 필요성

- 빠르게 변화하는 비즈니스 환경에서는 기존 코드의 구조적인 한계가 드러날 수 있음
- 이때 자바스크립트 코드를 타입스크립트 코드로 변환하는 것은 현재 비즈니스 로직에 맞지 않는 인터페이스만 추가하는 작업에 불과할 수 있음
- 마이그레이션 과정 자체에 대한 의구심을 불러일으킬 수 있으며, 타입스크립트 코드로 성공적으로 변환을 마치더라도 타입스크립트의 장점을 충분히 활용하기 어려울 수 있음
- 상황에 따라 새로운 설계를 기반으로 타입을 작성하는 게 효율적일 수 있음

### (2) 점진적인 마이그레이션

- 작은 부분부터 시작하여 점차 범위를 넓혀가며 마이그레이션 진행
- 데드라인이 없는 프로젝트는 언제 완료될지 모르는 과도기에 빠질 수 있음
- 프로젝트 참여자와 함께 우선순위를 대략적이라도 설정해두는 게 좋음

### (3) 마이그레이션 진행하기

- 타입스크립트 개발 환경 설정, 빌드 파이프라인에 타입스크립트 컴파일러 통합
- tsconfig.json 파일: allowJS - true, noImplicitAny - false 설정
- 자바스크립트 파일을 타입스크립트 파일로 변환
- tsconfig.json 파일: allowJS - false, noImplicitAny - true 설정하여 타입 명시되지 않은 부분이 없는지 점검

## 12.4 모노레포

- 여러 프로젝트를 관리할 때 개별 프로젝트마다 별도의 레포지토리를 생성하여 관리함
- 여러 프로젝트의 공통된 요소를 찾아낼 수 있다면 통합하여 좀 더 효율적으로 관리할 수 있음

### (1) 분산된 구조의 문제점

- 여러 프로젝트에 동일한 코드를 복사하여 붙여 넣은 후 뒤늦게 새로운 버그가 발견되거나 기능 확장을 위해 해당 기능을 수정해야 할 때 프로젝트의 개수만큼 반복적인 수정 작업을 해야 함
- 개발자가 변경이 필요한 지점을 모두 인지하고 있어야 하기 때문에 개발자 경험(DX)이 저하될 수 있음
- 분산된 구조는 생산성을 떨어뜨리는 결과를 초래함
- 반복되는 코드를 함수화하여 통합하듯이 한 곳에서 프로젝트를 관리할 수 있도록 통합해야 함

### (2) 통합할 수 있는 요소 찾기

- 통합할 수 있는 파일을 찾은 뒤 각 파일의 소스코드가 같지 않다면 통합을 위해 일부 수정

### (3) 공통 모듈화로 관리하기

- 소스코드를 수정한 다음 모듈화를 통해 통합 가능
- npm과 같은 패키지 관리자를 활용하여 공통 모듈을 생성하고 관리하면 각 프로젝트에서 간편하게 모듈과 의존성을 맺고 사용할 수 있게 됨
- 모듈을 통해 코드 재사용이 가능하고, 변경이 필요할 경우 모듈의 소스코드만 수정하면 되기 때문에 유지보수도 쉬워짐
- 공통 모듈에 변경이 발생하면 해당 모듈을 사용하는 프로젝트에서도 추가 작업이 필요할 수 있음
- 공통 모듈의 개수가 늘어나면 관리해야 할 레포지토리도 그만큼 늘어남

### (4) 모노레포의 탄생

- 모노레포 : 버전 관리 시스템에서 여러 프로젝트를 하나의 레포지토리로 통합하여 관리하는 소프트웨어 개발 전략
- 이전에는 다양한 기능을 가진 프로젝트를 하나의 레포지토리로 관리하는 모놀리식 기법을 주로 사용함
- 모놀리식 구조는 코드 간의 직접적인 의존이 발생하여 일부 로직이 변경될 때도 전체 프로젝트에 영향을 줄 수 있음
- 거대한 프로젝트를 작은 프로젝트의 집합으로 나누어 관리하는 폴리레포 방식과 하나의 레포지토리로 모든 것을 관리하는 모노레포 방식이 등장하게 됨
- 모노레포를 사용하면 개발 환경 설정도 통합할 수 있어서 더 효율적인 관리가 가능해짐
- 모노레포로 관리했을 때의 장점
  - 여러 프로젝트를 하나의 레포지토리로 통합하여 관리하며, 프로젝트마다 개별적인 레포지토리를 만드는 방식과는 달리 개발 환경 설정도 통합적으로 관리하기 때문에 불필요한 코드 중복을 줄여줌
  - 공통 모듈도 동일한 프로젝트 내에서 관리되므로 별도의 패키지 관리자를 통해 모듈을 게시하지 않아도 됨
- 모노레포로 관리했을 때의 단점
  - 레포지토리가 거대해졌을 때 하나의 레포지토리에 여러 팀의 이해관계가 얽혀있다면 소유권과 권한 관리가 복잡해질 수 있음
  - 각 프로젝트나 모듈의 소유권을 명확히 정의하고 규칙을 설정해야 하는 과정이 별도로 필요함
